# Задание 2. Подсчитать четные и нечетные цифры введенного натурального числа.
# Например, если введено число 34560, то у него 3 четные цифры
# (4, 6 и 0) и 2 нечетные (3 и 5).
# Подсказка:
# На каждом шаге вам нужно 'доставать' из числа очередную цифру
# и смотреть является ли она четной или нечетной.
# При этом увеличиваем соответствующий счетчик
# Пока все числа не извлечены, рекурсивные вызовы продолжаем
# Условие завершения рекурсии - все числа извлечены
# Используем операции % //. Операции взятия по индексу применять нельзя.

# even и odd - счётчики чётных/нечётных цифр, при первом вызове должны быть 0
def recursive_counter(number, even=0, odd=0):
    # проверяем, не пора ли остановить рекурсию:
    if number <= 0:  # дошли до нуля - пора. Кроме того, с отриц. числами будут проблемы.
        return even, odd  # возвращаем кортеж значений
    # отрезаем от числа последнюю цифру делением на 10.
    # divmod() - встроенная функция питона
    reduced_number, last_digit = divmod(number, 10)
    if last_digit % 2 == 0:  # последняя цифра чётная
        # значит, на одну больше чётную цифру
        return recursive_counter(reduced_number, even + 1,
                                 odd)  # уходим в рекурсию
    else:  # последняя цифра нечётная
        # значит, на одну больше нечётную цифру
        return recursive_counter(reduced_number, even,
                                 odd + 1)  # уходим в рекурсию

N = int(input("Введите число: "))
even, odd = recursive_counter(
    N)  # распаковываем кортеж, который вернула функция
print(f'В числе {N} есть {even} чётных цифр и {odd} нечётных.')
